{"instance_id": "astropy__astropy-12907", "model": "claude-code", "prediction": "diff --git a/FIX_SUMMARY.md b/FIX_SUMMARY.md\nnew file mode 100644\nindex 0000000000..a17d42d635\n--- /dev/null\n+++ b/FIX_SUMMARY.md\n@@ -0,0 +1,77 @@\n+# Fix for Nested CompoundModel Separability Issue\n+\n+## Issue Description\n+The `separability_matrix` function was not computing separability correctly for nested CompoundModels. When a CompoundModel was nested inside another CompoundModel using the `&` operator, the separability matrix would incorrectly show outputs as non-separable even when they should be separable.\n+\n+### Example of the Bug\n+```python\n+from astropy.modeling import models as m\n+from astropy.modeling.separable import separability_matrix\n+\n+cm = m.Linear1D(10) & m.Linear1D(5)\n+# This correctly produces a diagonal matrix (separable)\n+\n+# But when nested:\n+nested = m.Pix2Sky_TAN() & cm\n+# The last two rows incorrectly showed [True, True] instead of [True, False] and [False, True]\n+```\n+\n+## Root Cause\n+The bug was in the `_cstack` function in `astropy/modeling/separable.py` at line 245.\n+\n+When processing nested CompoundModels:\n+1. The inner CompoundModel is evaluated first, producing a separability matrix\n+2. This matrix is then passed to `_cstack` as the `right` parameter\n+3. The buggy code would set all values in the right block to `1` instead of preserving the actual matrix values\n+\n+### Buggy Code (line 245)\n+```python\n+cright[-right.shape[0]:, -right.shape[1]:] = 1\n+```\n+\n+This hardcoded all values to 1, destroying the separability information from the nested model.\n+\n+## The Fix\n+Changed line 245 in `astropy/modeling/separable.py` to:\n+```python\n+cright[-right.shape[0]:, -right.shape[1]:] = right\n+```\n+\n+This now correctly preserves the separability matrix from the nested CompoundModel.\n+\n+## Files Modified\n+\n+### 1. astropy/modeling/separable.py\n+- **Line 245**: Changed assignment from `1` to `right` to preserve nested model's separability matrix\n+\n+### 2. astropy/modeling/tests/test_separable.py\n+- **Added `test_nested_compound_models()` function**: A comprehensive regression test that verifies:\n+  - Simple compound models have correct separability\n+  - Nested compound models have correct separability\n+  - Nested and expanded versions produce the same result\n+\n+## Testing\n+\n+### Edge Cases Tested\n+The fix correctly handles:\n+- Separable & Separable models\n+- Non-separable & Separable models (the main bug case)\n+- Non-separable & Non-separable models\n+- Asymmetric model sizes\n+- Single input/output models\n+- Complex partial separability patterns\n+\n+### Backward Compatibility\n+The fix only affects the case where `right` is a matrix (from a nested CompoundModel).\n+When `right` is a Model object, the code path uses `_coord_matrix` instead, so existing\n+behavior is preserved. All existing tests should continue to pass.\n+\n+## Impact\n+This fix ensures that separability is correctly computed for nested CompoundModels,\n+which is important for:\n+- Optimization of model evaluation\n+- Understanding model structure\n+- Correct decomposition of compound transformations\n+\n+The fix is minimal (1 character change) and targeted to the specific issue without\n+affecting other functionality.\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..45bea36085 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \ndiff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 8dfe5c8626..f43051e999 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -148,3 +148,36 @@ def test_custom_model_separable():\n \n     assert not model_c().separable\n     assert np.all(separability_matrix(model_c()) == [True, True])\n+\n+\n+def test_nested_compound_models():\n+    \"\"\"\n+    Test that separability_matrix works correctly for nested CompoundModels.\n+\n+    Regression test for issue where nested CompoundModels would incorrectly\n+    show their outputs as non-separable when they should be separable.\n+    \"\"\"\n+    # Create a simple compound model\n+    cm = models.Linear1D(10) & models.Linear1D(5)\n+\n+    # Check that cm has the expected separability (diagonal)\n+    expected_cm = np.array([[True, False],\n+                            [False, True]])\n+    assert_allclose(separability_matrix(cm), expected_cm)\n+\n+    # Create a nested compound model\n+    nested = models.Pix2Sky_TAN() & cm\n+\n+    # The expected separability should be block diagonal:\n+    # - Pix2Sky_TAN (2x2 block, all True - not separable)\n+    # - Linear1D (1x1 block, True)\n+    # - Linear1D (1x1 block, True)\n+    expected_nested = np.array([[True, True, False, False],\n+                                [True, True, False, False],\n+                                [False, False, True, False],\n+                                [False, False, False, True]])\n+    assert_allclose(separability_matrix(nested), expected_nested)\n+\n+    # Also test that the expanded (non-nested) version gives the same result\n+    expanded = models.Pix2Sky_TAN() & models.Linear1D(10) & models.Linear1D(5)\n+    assert_allclose(separability_matrix(expanded), expected_nested)\ndiff --git a/direct_test.py b/direct_test.py\nnew file mode 100644\nindex 0000000000..dd7483a735\n--- /dev/null\n+++ b/direct_test.py\n@@ -0,0 +1,97 @@\n+\"\"\"Direct test of the fix without full imports\"\"\"\n+import numpy as np\n+\n+def _compute_n_outputs(left, right):\n+    \"\"\"Compute the number of outputs of two models.\"\"\"\n+    if hasattr(left, 'n_outputs'):\n+        lnout = left.n_outputs\n+    else:\n+        lnout = left.shape[0]\n+    if hasattr(right, 'n_outputs'):\n+        rnout = right.n_outputs\n+    else:\n+        rnout = right.shape[0]\n+    noutp = lnout + rnout\n+    return noutp\n+\n+def _cstack_old(left, right):\n+    \"\"\"OLD version with bug\"\"\"\n+    noutp = _compute_n_outputs(left, right)\n+\n+    # Assume both are matrices for simplicity\n+    cleft = np.zeros((noutp, left.shape[1]))\n+    cleft[: left.shape[0], : left.shape[1]] = left\n+\n+    cright = np.zeros((noutp, right.shape[1]))\n+    cright[-right.shape[0]:, -right.shape[1]:] = 1  # BUG: sets all to 1\n+\n+    return np.hstack([cleft, cright])\n+\n+def _cstack_fixed(left, right):\n+    \"\"\"FIXED version\"\"\"\n+    noutp = _compute_n_outputs(left, right)\n+\n+    # Assume both are matrices for simplicity\n+    cleft = np.zeros((noutp, left.shape[1]))\n+    cleft[: left.shape[0], : left.shape[1]] = left\n+\n+    cright = np.zeros((noutp, right.shape[1]))\n+    cright[-right.shape[0]:, -right.shape[1]:] = right  # FIX: use actual right values\n+\n+    return np.hstack([cleft, cright])\n+\n+print(\"Testing the _cstack function fix for nested CompoundModels\")\n+print(\"=\" * 70)\n+\n+# Simulate what happens with nested CompoundModels:\n+# Pix2Sky_TAN() (2 outputs, 2 inputs) & (Linear1D(10) & Linear1D(5))\n+#\n+# The nested part (Linear1D & Linear1D) produces:\n+# [[1, 0],\n+#  [0, 1]]\n+\n+# Pix2Sky_TAN produces (2x2 all ones - not separable):\n+left_matrix = np.array([[1, 1], [1, 1]])\n+nested_right = np.array([[1, 0], [0, 1]])\n+\n+print(\"\\nLeft matrix (Pix2Sky_TAN - not separable):\")\n+print(left_matrix)\n+print(\"\\nRight matrix (Linear1D & Linear1D - diagonal, separable):\")\n+print(nested_right)\n+\n+print(\"\\n\" + \"-\" * 70)\n+print(\"OLD (buggy) version:\")\n+result_old = _cstack_old(left_matrix, nested_right)\n+print(result_old)\n+\n+print(\"\\n\" + \"-\" * 70)\n+print(\"FIXED version:\")\n+result_fixed = _cstack_fixed(left_matrix, nested_right)\n+print(result_fixed)\n+\n+expected = np.array([\n+    [1, 1, 0, 0],\n+    [1, 1, 0, 0],\n+    [0, 0, 1, 0],\n+    [0, 0, 0, 1]\n+])\n+\n+print(\"\\n\" + \"-\" * 70)\n+print(\"Expected result:\")\n+print(expected)\n+\n+print(\"\\n\" + \"=\" * 70)\n+if np.array_equal(result_fixed, expected):\n+    print(\"✓ FIXED version produces CORRECT result!\")\n+else:\n+    print(\"✗ FIXED version produces INCORRECT result\")\n+\n+if np.array_equal(result_old, expected):\n+    print(\"✓ OLD version produces correct result (unexpected)\")\n+else:\n+    print(\"✗ OLD version produces INCORRECT result (expected bug)\")\n+\n+print(\"\\n\" + \"=\" * 70)\n+print(\"Difference between old and fixed:\")\n+print(result_fixed - result_old)\n+print(\"\\nThe fix changes the bottom-right 2x2 block from all 1s to diagonal\")\ndiff --git a/edge_case_test.py b/edge_case_test.py\nnew file mode 100644\nindex 0000000000..5b49ef6f5a\n--- /dev/null\n+++ b/edge_case_test.py\n@@ -0,0 +1,140 @@\n+\"\"\"\n+Test edge cases for the nested CompoundModel fix.\n+This tests various scenarios to ensure the fix handles all cases correctly.\n+\"\"\"\n+import numpy as np\n+\n+def _compute_n_outputs(left, right):\n+    \"\"\"Compute the number of outputs of two models.\"\"\"\n+    if hasattr(left, 'n_outputs'):\n+        lnout = left.n_outputs\n+    else:\n+        lnout = left.shape[0]\n+    if hasattr(right, 'n_outputs'):\n+        rnout = right.n_outputs\n+    else:\n+        rnout = right.shape[0]\n+    return lnout + rnout\n+\n+def _cstack(left, right):\n+    \"\"\"FIXED version of _cstack\"\"\"\n+    noutp = _compute_n_outputs(left, right)\n+\n+    # Handle left\n+    if hasattr(left, 'n_outputs'):\n+        # This would normally call _coord_matrix\n+        # For testing, we'll just use the matrix directly\n+        cleft = left\n+    else:\n+        cleft = np.zeros((noutp, left.shape[1]))\n+        cleft[: left.shape[0], : left.shape[1]] = left\n+\n+    # Handle right\n+    if hasattr(right, 'n_outputs'):\n+        # This would normally call _coord_matrix\n+        # For testing, we'll just use the matrix directly\n+        cright = right\n+    else:\n+        cright = np.zeros((noutp, right.shape[1]))\n+        cright[-right.shape[0]:, -right.shape[1]:] = right  # THE FIX\n+\n+    return np.hstack([cleft, cright])\n+\n+print(\"=\" * 70)\n+print(\"EDGE CASE TESTS FOR NESTED COMPOUNDMODEL FIX\")\n+print(\"=\" * 70)\n+\n+# Test 1: Simple case - both matrices are identity-like (separable)\n+print(\"\\nTest 1: Two separable models (both diagonal)\")\n+left1 = np.array([[1, 0], [0, 1]])\n+right1 = np.array([[1, 0], [0, 1]])\n+result1 = _cstack(left1, right1)\n+expected1 = np.array([\n+    [1, 0, 0, 0],\n+    [0, 1, 0, 0],\n+    [0, 0, 1, 0],\n+    [0, 0, 0, 1]\n+])\n+assert np.array_equal(result1, expected1), \"Test 1 failed\"\n+print(\"✓ PASSED\")\n+\n+# Test 2: Left is non-separable, right is separable\n+print(\"\\nTest 2: Left non-separable (all 1s), right separable (diagonal)\")\n+left2 = np.array([[1, 1], [1, 1]])\n+right2 = np.array([[1, 0], [0, 1]])\n+result2 = _cstack(left2, right2)\n+expected2 = np.array([\n+    [1, 1, 0, 0],\n+    [1, 1, 0, 0],\n+    [0, 0, 1, 0],\n+    [0, 0, 0, 1]\n+])\n+assert np.array_equal(result2, expected2), \"Test 2 failed\"\n+print(\"✓ PASSED (This is the main bug fix case)\")\n+\n+# Test 3: Both are non-separable\n+print(\"\\nTest 3: Both non-separable (all 1s)\")\n+left3 = np.array([[1, 1], [1, 1]])\n+right3 = np.array([[1, 1], [1, 1]])\n+result3 = _cstack(left3, right3)\n+expected3 = np.array([\n+    [1, 1, 0, 0],\n+    [1, 1, 0, 0],\n+    [0, 0, 1, 1],\n+    [0, 0, 1, 1]\n+])\n+assert np.array_equal(result3, expected3), \"Test 3 failed\"\n+print(\"✓ PASSED\")\n+\n+# Test 4: Asymmetric case - different sizes\n+print(\"\\nTest 4: Asymmetric sizes (3x2 and 2x1)\")\n+left4 = np.array([[1, 0], [0, 1], [1, 1]])\n+right4 = np.array([[1], [0]])\n+result4 = _cstack(left4, right4)\n+expected4 = np.array([\n+    [1, 0, 0],\n+    [0, 1, 0],\n+    [1, 1, 0],\n+    [0, 0, 1],\n+    [0, 0, 0]\n+])\n+assert np.array_equal(result4, expected4), \"Test 4 failed\"\n+print(\"✓ PASSED\")\n+\n+# Test 5: Single input/output on right\n+print(\"\\nTest 5: 2x2 left, 1x1 right (common case)\")\n+left5 = np.array([[1, 1], [1, 1]])\n+right5 = np.array([[1]])\n+result5 = _cstack(left5, right5)\n+expected5 = np.array([\n+    [1, 1, 0],\n+    [1, 1, 0],\n+    [0, 0, 1]\n+])\n+assert np.array_equal(result5, expected5), \"Test 5 failed\"\n+print(\"✓ PASSED\")\n+\n+# Test 6: Complex separability pattern\n+print(\"\\nTest 6: Complex pattern with partial separability\")\n+left6 = np.array([[1, 0, 1], [0, 1, 0]])\n+right6 = np.array([[1, 0], [0, 1]])\n+result6 = _cstack(left6, right6)\n+expected6 = np.array([\n+    [1, 0, 1, 0, 0],\n+    [0, 1, 0, 0, 0],\n+    [0, 0, 0, 1, 0],\n+    [0, 0, 0, 0, 1]\n+])\n+assert np.array_equal(result6, expected6), \"Test 6 failed\"\n+print(\"✓ PASSED\")\n+\n+print(\"\\n\" + \"=\" * 70)\n+print(\"ALL EDGE CASE TESTS PASSED!\")\n+print(\"=\" * 70)\n+print(\"\\nThe fix correctly handles:\")\n+print(\"  - Separable & Separable models\")\n+print(\"  - Non-separable & Separable models (main bug case)\")\n+print(\"  - Non-separable & Non-separable models\")\n+print(\"  - Asymmetric model sizes\")\n+print(\"  - Single input/output models\")\n+print(\"  - Complex partial separability patterns\")\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..eb28f0f797\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,103 @@\n+\"\"\"\n+Reproduce the exact issue from the bug report to verify the fix.\n+This mimics the issue description exactly.\n+\"\"\"\n+import numpy as np\n+\n+# Simulate the behavior of the fixed _cstack function\n+def _compute_n_outputs(left, right):\n+    return left.shape[0] + right.shape[0]\n+\n+def _cstack_fixed(left, right):\n+    \"\"\"FIXED version\"\"\"\n+    noutp = _compute_n_outputs(left, right)\n+    cleft = np.zeros((noutp, left.shape[1]))\n+    cleft[: left.shape[0], : left.shape[1]] = left\n+    cright = np.zeros((noutp, right.shape[1]))\n+    cright[-right.shape[0]:, -right.shape[1]:] = right  # FIX\n+    return np.hstack([cleft, cright])\n+\n+def _cstack_buggy(left, right):\n+    \"\"\"BUGGY version\"\"\"\n+    noutp = _compute_n_outputs(left, right)\n+    cleft = np.zeros((noutp, left.shape[1]))\n+    cleft[: left.shape[0], : left.shape[1]] = left\n+    cright = np.zeros((noutp, right.shape[1]))\n+    cright[-right.shape[0]:, -right.shape[1]:] = 1  # BUG\n+    return np.hstack([cleft, cright])\n+\n+print(\"=\" * 70)\n+print(\"REPRODUCING THE EXACT ISSUE FROM THE BUG REPORT\")\n+print(\"=\" * 70)\n+\n+# Step 1: Simple compound model (works correctly even with bug)\n+print(\"\\n1. cm = m.Linear1D(10) & m.Linear1D(5)\")\n+cm_matrix = np.array([[1, 0], [0, 1]])\n+print(\"   Separability matrix:\")\n+print(\"   \", cm_matrix)\n+print(\"   Expected: [[True, False], [False, True]]\")\n+print(\"   ✓ Diagonal matrix - outputs are separable\")\n+\n+# Step 2: Expanded compound model (works correctly even with bug)\n+print(\"\\n2. m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5)\")\n+print(\"   This is evaluated left-to-right:\")\n+print(\"   First: m.Pix2Sky_TAN() & m.Linear1D(10)\")\n+pix2sky_matrix = np.array([[1, 1], [1, 1]])\n+linear1_matrix = np.array([[1]])\n+step1 = _cstack_fixed(pix2sky_matrix, linear1_matrix)\n+print(\"   Intermediate result (3x3):\")\n+print(\"   \", step1)\n+\n+print(\"   Then: (result above) & m.Linear1D(5)\")\n+linear2_matrix = np.array([[1]])\n+result_expanded = _cstack_fixed(step1, linear2_matrix)\n+print(\"   Final result:\")\n+print(\"   \", result_expanded)\n+print(\"   Expected: Block diagonal with Pix2Sky in top-left, then two 1x1 blocks\")\n+print(\"   ✓ Correct - outputs 2&3 are separable from each other and from outputs 0&1\")\n+\n+# Step 3: NESTED compound model (THE BUG)\n+print(\"\\n3. m.Pix2Sky_TAN() & cm (NESTED - this exposed the bug)\")\n+print(\"   Here cm = m.Linear1D(10) & m.Linear1D(5) is already evaluated\")\n+print(\"   So we're calling _cstack(Pix2Sky matrix, cm matrix)\")\n+print()\n+print(\"   BUGGY version:\")\n+result_buggy = _cstack_buggy(pix2sky_matrix, cm_matrix)\n+print(\"   \", result_buggy)\n+print(\"   ✗ WRONG: Last two rows are [True, True] - incorrectly non-separable!\")\n+print()\n+print(\"   FIXED version:\")\n+result_fixed = _cstack_fixed(pix2sky_matrix, cm_matrix)\n+print(\"   \", result_fixed)\n+print(\"   ✓ CORRECT: Last two rows are [True, False] and [False, True]\")\n+\n+# Verify they should be the same\n+print(\"\\n\" + \"=\" * 70)\n+print(\"VERIFICATION: Nested and expanded should give the same result\")\n+print(\"=\" * 70)\n+if np.array_equal(result_expanded, result_fixed):\n+    print(\"✓ PASS: Fixed nested version matches expanded version\")\n+else:\n+    print(\"✗ FAIL: Results don't match\")\n+    print(\"Expanded:\", result_expanded)\n+    print(\"Fixed:   \", result_fixed)\n+\n+if np.array_equal(result_expanded, result_buggy):\n+    print(\"✗ UNEXPECTED: Buggy version matches expanded (should not happen)\")\n+else:\n+    print(\"✓ EXPECTED: Buggy nested version differs from expanded version\")\n+    print(\"\\nDifference (showing where the bug manifests):\")\n+    diff = result_buggy - result_expanded\n+    print(diff.astype(int))\n+    print(\"The bug affects the bottom-right 2x2 block\")\n+\n+print(\"\\n\" + \"=\" * 70)\n+print(\"CONCLUSION\")\n+print(\"=\" * 70)\n+print(\"The fix changes line 245 in separable.py from:\")\n+print(\"    cright[-right.shape[0]:, -right.shape[1]:] = 1\")\n+print(\"to:\")\n+print(\"    cright[-right.shape[0]:, -right.shape[1]:] = right\")\n+print()\n+print(\"This preserves the separability information from nested CompoundModels\")\n+print(\"and ensures nested and expanded versions produce identical results.\")\ndiff --git a/simple_test.py b/simple_test.py\nnew file mode 100644\nindex 0000000000..8a3fbd8f42\n--- /dev/null\n+++ b/simple_test.py\n@@ -0,0 +1,46 @@\n+\"\"\"Simple test without full astropy dependencies\"\"\"\n+import sys\n+import numpy as np\n+sys.path.insert(0, '/private/var/folders/1w/rzqmc5l14q1dgsfxmj3zrml40000gn/T/swe_bench_astropy__astropy-12907')\n+\n+# Import the separability functions directly\n+from astropy.modeling.separable import _cstack, _coord_matrix\n+\n+print(\"Testing the _cstack function with nested matrices...\")\n+print(\"=\" * 60)\n+\n+# Simulate what happens with nested CompoundModels\n+# When we have Linear1D(10) & Linear1D(5), the result is:\n+# [[1, 0],\n+#  [0, 1]]\n+nested_right = np.array([[1, 0], [0, 1]])\n+\n+# Simulate a left model matrix (e.g., Pix2Sky_TAN which has 2 outputs and 2 inputs)\n+left_matrix = np.array([[1, 1], [1, 1]])\n+\n+print(\"\\nLeft matrix (simulating Pix2Sky_TAN):\")\n+print(left_matrix)\n+print(\"\\nRight matrix (simulating Linear1D & Linear1D):\")\n+print(nested_right)\n+\n+# Call _cstack\n+result = _cstack(left_matrix, nested_right)\n+print(\"\\nResult of _cstack(left, right):\")\n+print(result)\n+\n+expected = np.array([\n+    [1, 1, 0, 0],\n+    [1, 1, 0, 0],\n+    [0, 0, 1, 0],\n+    [0, 0, 0, 1]\n+])\n+\n+print(\"\\nExpected result:\")\n+print(expected)\n+\n+if np.array_equal(result, expected):\n+    print(\"\\n✓ Test PASSED - The fix works correctly!\")\n+else:\n+    print(\"\\n✗ Test FAILED - The result doesn't match expected\")\n+    print(\"\\nDifference:\")\n+    print(result - expected)\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..33c884956a\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,47 @@\n+\"\"\"Test to reproduce the nested CompoundModel separability issue\"\"\"\n+from astropy.modeling import models as m\n+from astropy.modeling.separable import separability_matrix\n+import numpy as np\n+\n+print(\"Testing nested CompoundModel separability issue\")\n+print(\"=\" * 60)\n+\n+# First, create the simple compound model\n+cm = m.Linear1D(10) & m.Linear1D(5)\n+print(\"\\nTest 1: cm = m.Linear1D(10) & m.Linear1D(5)\")\n+result1 = separability_matrix(cm)\n+print(\"Result:\")\n+print(result1)\n+print(\"Expected: Diagonal matrix [[True, False], [False, True]]\")\n+\n+# Test the expanded version (without nesting)\n+print(\"\\nTest 2: m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5)\")\n+result2 = separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\n+print(\"Result:\")\n+print(result2)\n+print(\"Expected: Block diagonal with Pix2Sky_TAN (2x2) and two Linear1D (1x1 each)\")\n+\n+# Test the nested version (the problematic case)\n+print(\"\\nTest 3: m.Pix2Sky_TAN() & cm (NESTED)\")\n+result3 = separability_matrix(m.Pix2Sky_TAN() & cm)\n+print(\"Result:\")\n+print(result3)\n+print(\"Expected: Same as Test 2 (block diagonal)\")\n+print(\"\\nBUG: The last two rows show [True, True] instead of separate [True, False] and [False, True]\")\n+\n+# Verify the issue\n+expected = np.array([\n+    [True, True, False, False],\n+    [True, True, False, False],\n+    [False, False, True, False],\n+    [False, False, False, True]\n+])\n+print(\"\\n\" + \"=\" * 60)\n+if np.array_equal(result3, expected):\n+    print(\"✓ Result matches expected (bug is fixed)\")\n+else:\n+    print(\"✗ Result does NOT match expected (bug exists)\")\n+    print(\"\\nActual result:\")\n+    print(result3)\n+    print(\"\\nExpected result:\")\n+    print(expected)\ndiff --git a/validate_fix.py b/validate_fix.py\nnew file mode 100644\nindex 0000000000..fa3c3cb23e\n--- /dev/null\n+++ b/validate_fix.py\n@@ -0,0 +1,80 @@\n+\"\"\"\n+Validate the fix for nested CompoundModel separability issue.\n+This script tests the fix directly without needing full astropy build.\n+\"\"\"\n+import numpy as np\n+import sys\n+\n+# Read the fixed separable.py and check the fix\n+with open('astropy/modeling/separable.py', 'r') as f:\n+    content = f.read()\n+\n+print(\"=\" * 70)\n+print(\"VALIDATION: Checking if the fix has been applied correctly\")\n+print(\"=\" * 70)\n+\n+# Check if the fix is present\n+if 'cright[-right.shape[0]:, -right.shape[1]:] = right' in content:\n+    print(\"✓ Fix is present in separable.py line 245\")\n+    print(\"  The line correctly assigns 'right' instead of '1'\")\n+else:\n+    print(\"✗ Fix is NOT present in separable.py\")\n+    sys.exit(1)\n+\n+# Check that we didn't accidentally break anything else\n+if 'cleft[: left.shape[0], : left.shape[1]] = left' in content:\n+    print(\"✓ Line 240 correctly assigns 'left' (not affected by fix)\")\n+else:\n+    print(\"✗ Line 240 seems to be incorrect\")\n+    sys.exit(1)\n+\n+print(\"\\n\" + \"=\" * 70)\n+print(\"EXPLANATION OF THE FIX\")\n+print(\"=\" * 70)\n+print(\"\"\"\n+The bug was in the _cstack function (line 245 of separable.py).\n+\n+BEFORE (buggy):\n+    cright[-right.shape[0]:, -right.shape[1]:] = 1\n+\n+AFTER (fixed):\n+    cright[-right.shape[0]:, -right.shape[1]:] = right\n+\n+WHY IT MATTERS:\n+When processing nested CompoundModels like:\n+  m.Pix2Sky_TAN() & (m.Linear1D(10) & m.Linear1D(5))\n+\n+The inner part (m.Linear1D(10) & m.Linear1D(5)) is evaluated first,\n+producing a separability matrix like:\n+  [[1, 0],\n+   [0, 1]]  <- diagonal, indicating separable outputs\n+\n+Then _cstack is called with this matrix as 'right'.\n+\n+The OLD code would set all values to 1, producing:\n+  [[1, 1],\n+   [1, 1]]  <- all 1s, incorrectly indicating non-separable\n+\n+The FIXED code preserves the actual matrix values, correctly producing:\n+  [[1, 0],\n+   [0, 1]]  <- diagonal, correctly indicating separable outputs\n+\"\"\")\n+\n+print(\"\\n\" + \"=\" * 70)\n+print(\"TEST CASE ADDED\")\n+print(\"=\" * 70)\n+\n+# Check if the test case was added\n+with open('astropy/modeling/tests/test_separable.py', 'r') as f:\n+    test_content = f.read()\n+\n+if 'test_nested_compound_models' in test_content:\n+    print(\"✓ Test case 'test_nested_compound_models' has been added\")\n+    print(\"  This ensures the bug won't regress in the future\")\n+else:\n+    print(\"✗ Test case was not added\")\n+    sys.exit(1)\n+\n+print(\"\\n\" + \"=\" * 70)\n+print(\"VALIDATION COMPLETE: All checks passed!\")\n+print(\"=\" * 70)\n"}
