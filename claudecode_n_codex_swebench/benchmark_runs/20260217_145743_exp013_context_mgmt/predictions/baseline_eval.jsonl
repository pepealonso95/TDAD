{"instance_id": "astropy__astropy-12907", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..dcf2a74dd7 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -199,7 +199,7 @@ def _coord_matrix(model, pos, noutp):\n         else:\n             mat[-model.n_outputs:, -model.n_inputs:] = m\n         return mat\n-    if not model.separable:\n+    if not getattr(model, \"separable\", True):\n         # this does not work for more than 2 coordinates\n         mat = np.zeros((noutp, model.n_inputs))\n         if pos == 'left':\n"}
{"instance_id": "astropy__astropy-13033", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex c279f35f87..9dc6c3de99 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -70,15 +70,15 @@ class BaseTimeSeries(QTable):\n \n             if not self._required_columns_relax and len(self.colnames) == 0:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n+                raise ValueError(\"{} object is invalid - expected {} \"\n                                  \"as the first column{} but time series has no columns\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural))\n+                                 .format(self.__class__.__name__, required_columns, plural))\n \n             elif self.colnames[:len(required_columns)] != required_columns:\n \n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n+                raise ValueError(\"{} object is invalid - expected {} \"\n                                  \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n+                                 .format(self.__class__.__name__, required_columns, plural, self.colnames))\n \n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):\n"}
{"instance_id": "astropy__astropy-13236", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a3..06eb6f9f4d 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1239,13 +1239,9 @@ class Table:\n                                 f'{fully_qualified_name} '\n                                 'did not return a valid mixin column')\n \n-        # Structured ndarray gets viewed as a mixin unless already a valid\n         # mixin class\n-        if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n-            data = data.view(NdarrayMixin)\n             data_is_mixin = True\n-\n         # Get the final column name using precedence.  Some objects may not\n         # have an info attribute. Also avoid creating info as a side effect.\n         if not name:\n"}
{"instance_id": "astropy__astropy-13398", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py b/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py\nindex a15248c38d..3810c801a2 100644\n--- a/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py\n+++ b/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py\n@@ -7,12 +7,17 @@ rotations without aberration corrections or offsets.\n \n import numpy as np\n import erfa\n+from astropy import units as un\n \n from astropy.coordinates.baseframe import frame_transform_graph\n from astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n+from astropy.coordinates.matrix_utilities import rotation_matrix, matrix_transpose\n from astropy.coordinates.matrix_utilities import matrix_transpose\n \n from .icrs import ICRS\n+from .altaz import AltAz\n+from .hadec import HADec\n+from .utils import PIOVER2\n from .gcrs import GCRS, PrecessedGeocentric\n from .cirs import CIRS\n from .itrs import ITRS\n@@ -277,3 +282,54 @@ frame_transform_graph._add_merged_transform(ITRS, CIRS, ITRS)\n frame_transform_graph._add_merged_transform(PrecessedGeocentric, GCRS, PrecessedGeocentric)\n frame_transform_graph._add_merged_transform(TEME, ITRS, TEME)\n frame_transform_graph._add_merged_transform(TETE, ICRS, TETE)\n+\n+def itrs_to_observed_mat(observed_frame):\n+\n+    lon, lat, height = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        # form ITRS to AltAz matrix\n+        elat = lat.to_value(u.radian)\n+        # AltAz frame is left handed\n+        minus_x = np.eye(3)\n+        minus_x[0][0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+\n+    else:\n+        # form ITRS to HADec matrix\n+        # HADec frame is left handed\n+        minus_y = np.eye(3)\n+        minus_y[1][1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    # Trying to synchronize the obstimes here makes no sense. In fact,\n+    # it's a real gotcha as doing an ITRS->ITRS transform references \n+    # ITRS coordinates, which should be tied to the Earth, to the SSB.\n+    # Instead, we treat ITRS coordinates as time invariant here.\n+\n+    # form the Topocentric ITRS position\n+    topocentric_itrs_repr = (itrs_coo.cartesian\n+                             - observed_frame.location.get_itrs().cartesian)\n+    rep = topocentric_itrs_repr.transform(itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+               \n+    # form the Topocentric ITRS position\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(matrix_transpose(\n+                            itrs_to_observed_mat(observed_coo)))\n+    # form the Geocentric ITRS position\n+    rep = topocentric_itrs_repr + observed_coo.location.get_itrs().cartesian\n+    return itrs_frame.realize_frame(rep)\n"}
{"instance_id": "astropy__astropy-13453", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..e1a47cf511 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -406,6 +406,10 @@ class HTML(core.BaseReader):\n                     with w.tag('thead'):\n                         with w.tag('tr'):\n                             for col in cols:\n+        # set formatter\n+        for col in cols:\n+            if col.info.name in self.data.formats:\n+                col.info.format = self.data.formats[col.info.name]\n                                 if len(col.shape) > 1 and self.html['multicol']:\n                                     # Set colspan attribute for multicolumns\n                                     w.start('th', colspan=col.shape[1])\n"}
{"instance_id": "astropy__astropy-13579", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b078c..a6ae04dbc6 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -251,7 +251,29 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n+                # Compute correct world coordinate for dropped dimension\n+                # Find which pixel dimension corresponds to this world dimension\n+                pixel_dim = None\n+                for ipixel in range(self._wcs.pixel_n_dim):\n+                    if self._wcs.axis_correlation_matrix[iworld, ipixel]:\n+                        pixel_dim = ipixel\n+                        break\n+                # Get the pixel value that was sliced for this dimension\n+                if pixel_dim is not None:\n+                    slice_val = self._slices_pixel[pixel_dim]\n+                    if isinstance(slice_val, slice):\n+                        pixel_val = slice_val.start\n+                    else:\n+                        pixel_val = slice_val\n+                    # Create a pixel array with all values set to 0 except the relevant one\n+                    temp_pixels = [0] * self._wcs.pixel_n_dim\n+                    temp_pixels[pixel_dim] = pixel_val\n+                    # Get the world coordinate at this pixel\n+                    temp_world = self._wcs.pixel_to_world_values(*temp_pixels)\n+                    world_arrays_new.append(temp_world[iworld])\n+                else:\n+                    # Fallback\n+                    world_arrays_new.append(1.)\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n"}
{"instance_id": "astropy__astropy-13977", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..f2c82d7a47 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -667,7 +667,14 @@ class Quantity(np.ndarray):\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+        arrays = []\n+        for input_, converter in zip(inputs, converters):\n+            input_ = getattr(input_, \"value\", input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # If converter fails, return NotImplemented to allow fallback\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n"}
{"instance_id": "astropy__astropy-14096", "model_name_or_path": "qwen-mini", "model_patch": ""}
{"instance_id": "astropy__astropy-14182", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8efb..34b06eb5b1 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -57,10 +57,10 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, header_rows=None):\n+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)\n \n     def write(self, lines):\n         lines = super().write(lines)\n         lines = [lines[1]] + lines + [lines[1]]\n-        return lines\n+        return lines\n\\ No newline at end of file\n"}
{"instance_id": "astropy__astropy-14309", "model_name_or_path": "qwen-mini", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4ac..d4158f1a3b 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,7 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    if args:        return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))    return False\n \n \n def _decode_mixins(tbl):\n"}
