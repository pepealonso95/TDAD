{"instance_id": "astropy__astropy-12907", "model": "qwen-mini", "prediction": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..0de5a2cd13 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -241,8 +241,7 @@ def _cstack(left, right):\n     if isinstance(right, Model):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n-        cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright = right\n \n     return np.hstack([cleft, cright])\n \n"}
{"instance_id": "astropy__astropy-13033", "model": "qwen-mini", "prediction": ""}
{"instance_id": "astropy__astropy-13236", "model": "qwen-mini", "prediction": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a3..1f6ebfafb5 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1239,12 +1239,8 @@ class Table:\n                                 f'{fully_qualified_name} '\n                                 'did not return a valid mixin column')\n \n-        # Structured ndarray gets viewed as a mixin unless already a valid\n-        # mixin class\n-        if (not isinstance(data, Column) and not data_is_mixin\n-                and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n-            data = data.view(NdarrayMixin)\n-            data_is_mixin = True\n+        import warnings\n+        warnings.warn(\"Structured array input will be converted to Column in astropy 5.2. Wrap data in Column to avoid this warning.\", FutureWarning)\n \n         # Get the final column name using precedence.  Some objects may not\n         # have an info attribute. Also avoid creating info as a side effect.\n"}
{"instance_id": "astropy__astropy-13398", "model": "qwen-mini", "prediction": "diff --git a/astropy/coordinates/builtin_frames/__init__.py b/astropy/coordinates/builtin_frames/__init__.py\nindex 6fd688c285..76ceccd3cd 100644\n--- a/astropy/coordinates/builtin_frames/__init__.py\n+++ b/astropy/coordinates/builtin_frames/__init__.py\n@@ -41,6 +41,7 @@ from .equatorial import TEME, TETE\n from .ecliptic import *  # there are a lot of these so we don't list them all explicitly\n from .skyoffset import SkyOffsetFrame\n # need to import transformations so that they get registered in the graph\n+from . import itrs_observed_transforms\n from . import icrs_fk5_transforms\n from . import fk4_fk5_transforms\n from . import galactic_transforms\n"}
{"instance_id": "astropy__astropy-13453", "model": "qwen-mini", "prediction": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..34719dee01 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -354,6 +354,10 @@ class HTML(core.BaseReader):\n             self.data.fill_values = [self.data.fill_values]\n \n         self.data._set_fill_values(cols)\n+        # Apply formats if specified\n+        for col in cols:\n+            if col.info.name in self.data.formats:\n+                col.info.format = self.data.formats[col.info.name]\n \n         lines = []\n \n"}
{"instance_id": "astropy__astropy-13579", "model": "qwen-mini", "prediction": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b078c..4a99101f82 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -251,33 +251,35 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n-\n-        world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n-        pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n-\n-        for ipixel in range(self._wcs.pixel_n_dim):\n-            if isinstance(self._slices_pixel[ipixel], slice) and self._slices_pixel[ipixel].start is not None:\n-                pixel_arrays[ipixel] -= self._slices_pixel[ipixel].start\n-\n-        # Detect the case of a length 0 array\n-        if isinstance(pixel_arrays, np.ndarray) and not pixel_arrays.shape:\n-            return pixel_arrays\n-        pixel = tuple(pixel_arrays[ip] for ip in self._pixel_keep)\n-        if self.pixel_n_dim == 1 and self._wcs.pixel_n_dim > 1:\n-            pixel = pixel[0]\n-        return pixel\n-\n-    @property\n-    def world_axis_object_components(self):\n-        return [self._wcs.world_axis_object_components[idx] for idx in self._world_keep]\n-\n-    @property\n-    def world_axis_object_classes(self):\n-        keys_keep = [item[0] for item in self.world_axis_object_components]\n-        return dict([item for item in self._wcs.world_axis_object_classes.items() if item[0] in keys_keep])\n-\n-    @property\n+                # Calculate world coordinate for dropped dimension\n+                # Calculate world coordinate for dropped dimension\n+                # that corresponds to the pixel value in the slice\n+                # Get the world coordinate for the sliced pixel value\n+                # Find which pixel dimension corresponds to this world dimension\n+                ipixel = None\n+                for j in range(len(self._pixel_keep)):\n+                    if self._pixel_keep[j] == iworld:\n+                        ipixel = j\n+                        break\n+                # Get the pixel value that was sliced\n+                if ipixel is not None:\n+                    pixel_value = self._slices_pixel[ipixel]\n+                    if isinstance(pixel_value, int):\n+                        # Create a dummy array with the pixel value for the dropped dimension\n+                        # We need to compute the world coordinate for this pixel value\n+                        # Create a temporary pixel array with all dimensions\n+                        temp_pixel = [0] * self._wcs.pixel_n_dim\n+                        temp_pixel[ipixel] = pixel_value\n+                        # Compute world coordinates for this pixel\n+                        temp_world = self._wcs.pixel_to_world_values(*temp_pixel)\n+                        # Get the world coordinate for the dropped dimension\n+                        world_arrays_new.append(temp_world[iworld])\n+                    else:\n+                        # For slice objects, we use the start value\n+                        world_arrays_new.append(0.)\n+                else:\n+                    # Fallback - use 0 if we can't determine the pixel dimension\n+                    world_arrays_new.append(0.)\n     def array_shape(self):\n         if self._wcs.array_shape:\n             return np.broadcast_to(0, self._wcs.array_shape)[tuple(self._slices_array)].shape\n"}
{"instance_id": "astropy__astropy-13977", "model": "qwen-mini", "prediction": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..eea9eb873c 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -667,7 +667,10 @@ class Quantity(np.ndarray):\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n+        try:\n             arrays.append(converter(input_) if converter else input_)\n+        except ValueError:\n+            return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n"}
{"instance_id": "astropy__astropy-14096", "model": "qwen-mini", "prediction": ""}
{"instance_id": "astropy__astropy-14182", "model": "qwen-mini", "prediction": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8efb..d73b66c8b0 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -12,13 +12,6 @@ from .fixedwidth import (\n     FixedWidthTwoLineDataSplitter,\n )\n \n-\n-class SimpleRSTHeader(FixedWidthHeader):\n-    position_line = 0\n-    start_line = 1\n-    splitter_class = DefaultSplitter\n-    position_char = \"=\"\n-\n     def get_fixedwidth_params(self, line):\n         vals, starts, ends = super().get_fixedwidth_params(line)\n         # The right hand column can be unbounded\n@@ -33,6 +26,10 @@ class SimpleRSTData(FixedWidthData):\n \n \n class RST(FixedWidth):\n+    def __init__(self, header_rows=None):\n+        if header_rows is None:\n+            header_rows = [\"name\"]\n+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)\n     \"\"\"reStructuredText simple format table.\n \n     See: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#simple-tables\n@@ -57,9 +54,6 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n-\n     def write(self, lines):\n         lines = super().write(lines)\n         lines = [lines[1]] + lines + [lines[1]]\n"}
{"instance_id": "astropy__astropy-14309", "model": "qwen-mini", "prediction": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4ac..4bcb849623 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,9 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    if len(args) > 0:\n+        return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    return False\n \n \n def _decode_mixins(tbl):\n"}
